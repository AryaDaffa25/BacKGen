# BaKGen
A framework to generate background knowledge (BK) for knowledge prompting for a particular NLP downstream task. In this repository, we demonstrate how to generate BK using BacKGen and implement it for sentiment phrase classification (SPC) task.
## Brief Introduction
The problem of sample selection in few-shot prompting introduces knowledge and chain-of-taught prompting as the more robust alternative. Here, we propose BacKGen, a framework to generate background knowledge (BK) based on frame semantic theory that can be used for knowledge prompting. We tested the generated knowledge for knowledge prompting in solving SPC. The experiment results showed that the BK added in the prompt increased the performance with a significant impact on error reduction rate.
## Main Use
Using BacKGen for knowledge prompting consists of two main processes: <br />
1. `BK Generation`: This process is done to generate BK. Suppose that we have a collection of frames extracted from texts using a particular parser, we use BacKGen to cluster filter and cluster them. Then, we generate BK from the clustered frame using a particular LLM with a particular prompt template.
2. `BK Selection and Injection`: This process is done for bk injection shot (bk-shot). Suppose that we already obtain the generated BK, we select the top-n BK for each label based on a particual similarity function (frame or text similarity), then inject it to the prompt.
## About Dataset
In folder `data`, we provided three sub-folders: <br />
1. `5_fold_bk`: This folder contains the BK database that can be directly used for sentiment analysis on environmental sustainability (ES) issues using bk-shot.
2. `5_fold_frame_spc`: This folder contains our 5_fold data for reproducibility and development needs in sentiment phrase classification (SPC) on ES issues.
3. `mwe`: This folder contains the dataset for the minimum working example (MWE) of our BK generation, selection, and injection process. 
## Requirements
BacKGen is implemented in `Python 3` (tested on `Python 3.8.12` and `Python 3.10.2`) and requires a number of packages. To install the packages, simply run `$ pip install -r requirements.txt` in your virtual environment. For the `torch` version, you may need a different one following your `cuda` version. For frame clustering, you need `java` installed in your environment, where in our case we use `java 22`.

# Minimum Working Example (MWE)
In this MWE, we demonstrate how to use BacKGen to generate BK and use it for SPC task. Given a set of texts, our goal in this demonstration is to generate two BK databases i.e. BK for positive and negative polarity.
## BK Generation process
In general, generating BK using BacKGen consists of four major steps:
1. `Frame Extraction`: Given a set of texts, the first step is to extract the frame semantics of the frame. In this MWE, we use [LOME frame parser](https://aclanthology.org/2021.eacl-demos.19/) to extract the frame from text in `$ data/mwe/0_spc_data/mwe-train.jsonl` and store the result in `$ data/mwe/backgen_1_extracted_frame/mwe-train-frame.jsonl`.
2. `Frame Filtering`: In this MWE, we want to generate BK for SPC, we filter the `frame_file` (`$ data/mwe/backgen_1_extracted_frame/mwe-train-frame.jsonl`) to only use the frame that the frame element intersects with the target (sentiment) phrase in the `train_file` (`$ data/mwe/0_spc_data/mwe-train.jsonl`) by running the function `jsonl2jsonl_filter_sentiment_frame(train_file,frame_file,output_folder)` that written in `$ filterer/filter_sentiment_frame.py` file script. In this MWE, the filtered frames stored in the `output_folder` `$ data/mwe/backgen_2_filtered_frame`. As the frame clustering process needs `.klp` format, we convert the `.jsonl` filtered frame into the desired `.klp` format by running the function `jsonl2klp_frame2klp(input_file_path,output_file_path,bracket_type="round")` in the file script `$ converter/frame_converter.py`.
3. `Frame Clustering`: For this process, we use tree-kernel-based k-Means clustering provided by [KELP](https://jmlr.org/papers/v18/16-087.html). Suppose that we want to cluster the `positive_frame` in file `$ mwe/backgen_2_filtered_frame/mwe-train-frame_positive.klp` into 195 clusters with 10 of k-Means iteration process and then store the `clustering_result` in file `$ mwe/backgen_3_clustered_frame/mwe-train-clustered_positive.csv`, we move our working directory to `$ cd clusterer` folder and run the script `$ java -cp .:./lib/kelp-additional-algorithms-2.2.2.jar:lib/kelp-core-2.2.2.jar:lib/kelp-full2.0.2.jar KernelBasedFrameClustering positive_frame 195 10 > clustering_result`. As we do not need the singleton and need `.jsonl` format for the BK generation process, we filter and convert the clustered file into the desired `.jsonl` format by running the function `framecluster2jsonl(input_file_path,output_file_path,cluster_name,cluster_polarity)` in file script `$ converter/framecluster2jsonl.py`. This process is repeated for each label data, which in this MWE is repeated for the filtered negative polarity frame.
4. `BK Generation`: Using the file script `$ llm_inference/llm_inference_bulk.py`, we generate the BK for each cluster polarity. For custom prompts, we can define our prompt in the file script `$ llm_inference/get_prompt.py`. As the LLM output may contain noise, we clean the BK using the function `bk_preprocessor_file2file(input_file_path,output_file_path,clean_answer_mode)` in the file script `$ converter/pk_preprocessor.py`. Our generated BK in this MWE is stored in the folder `$ data/mwe/backgen_4_generated_bk`. If we later want to perform BK selection using frame filtering, we need to convert the generated BK to `.klp` format using the function `jsonlbk2klp(input_file_path,output_file_path)` written in the file script `$ converter/frame_converter.py`.
## BK Selection and Injection Process
BacKGen provides two approaches for BK selection i.e. based on text similarity and frame similarity. The BK selection based on text similarity is pretty direct, where we simply calculate the text-similarity of text instance with each original text of medoid and take the top-n BK based on the similarity score rank. Please explore and use the file script `$ get_bk/get_bk_exmbert_spc.py`. In this MWE, we demonstrate BK selection and injection based on frame similarity, which in general consists of five major steps:
1. `Frame Extraction`: Using [LOME frame parser](https://aclanthology.org/2021.eacl-demos.19/), we extract the text instance in file `$ data/mwe/0_spc_data/mwe-val.jsonl` and stored it in file `$ data/mwe/spc_1_extracted_frame/mwe-val-frame.jsonl`.
2. `Frame Filtering`: We filter the `frame_file` (`$ data/mwe/spc_1_extracted_frame/mwe-val-frame.jsonl`) based on the `target_phrase_file` (`$ data/mwe/0_spc_data/mwe-val-spc.jsonl`) using the function `jsonl2jsonl_filter_phrase_frame_st(target_phrase_file,frame_file,output_file)` written in the file script `$ filterer/filter_frame_splitted_st.py` and will produce the filtered frame `$ data/mwe/spc_2_filtered_frame/mwe-val-frame_filtered.jsonl`. As frame similarity scoring needs a `.klp` format, we convert the `.jsonl` filtered frame into the desired `.klp` format using the function `split_frame_jsonl2klp(input_file_path,output_file_path,bracket_type="round")` written in the file script `$ converter/frame_converter.py`.
3. `Frame Similarity Scoring`: We calculate the frame similarity of the filtered frame with each medoid frame using tree-kernel-based similarity provided by [KELP](https://jmlr.org/papers/v18/16-087.html). Suppose we want to calculate the frame similarity between the `filtered_frame` in the file `$ data/mwe/spc_2_filtered_frame/mwe-val-frame_filtered.jsonl` with the medoid frame of the `positive_cluster` in the file `$ data/mwe/backgen_4_generated_bk/mwe-bk_positive.klp` and store the `similarity_score` in the file `$ data/mwe/spc_3_sim_score/mwe-sim_score_positive.txt`, we move our working directory to `$ cd clusterer` folder and run the script `$ java -cp .:./lib/kelp-additional-algorithms-2.2.2.jar:lib/kelp-core-2.2.2.jar:lib/kelp-full2.0.2.jar KernelSimilarity filtered_frame positive_cluster similarity_score frame_syntaxtree`. This process is repeated for the `negative_cluster` so that we obtain two similarity score files as seen in the folder `$ data/mwe/spc_3_sim_score`.
4. `BK Selection`: From the obtained similarity score files, we can retrieve top-n BK for each BK's polarity database and add it to the SPC file instance `$ data/mwe/0_spc_data/mwe-val-spc.jsonl` by using the function `get_bk_spc(args)` written in the file `$ get_bk/get_bk_spc.py`. The result of this process is the original SPC file with the extra BK attribute as can be seen in the file `$ data/mwe/spc_4_selected_bk/mwe-val-bk_instance.jsonl`.
5. `BK Injection`: Using the file script `$ llm_inference/llm_inference_bulk.py` we inject the selected BK and perform bk-shot prompting using a particular LLM.  For custom prompts, we can define our prompt in the file `$ llm_inference/get_prompt_spc.py`. The output example of this process can be seen in the file `$ data/mwe/spc_5_bk_shot_result/mwe-val-bk_shot_result.jsonl`. Finally, we can post-process (to get the final answer) and evaluate the output using a particular post-processing and evaluation metric as we need.